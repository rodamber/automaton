* Report
** Content
- Introduction
  - Problem
  - Motivation
- Background Theory
- Solution
  - Representation
  - Approach
  - Results and conclusion
- Previous approaches
- Conclusion

** Introduction

*** Problem
*TODO*: NFAs with ε-transitions.

Development of a provably correct DFA to NFA transformation by powerset construction.

Proof of equivalence between DFAs and NFAs.

*TODO*: what does it mean to be 'provably correct'? What is the specification?

*** Motivation
The DFA to NFA transformation came as part of a project called _lexi_. _lexi_ is
a simple implementation of a lexer generator, written in Scala. It provides a
small DSL that allows you to define tokens using regular expressions and
compiles them to a DFA. The DFA outputs a sequence of tokens when given an
input string.

The DFA is obtained in two steps: we start by compiling the regular expression
to an NFA and then transform it to a DFA. In this project, we focus on the
latter step.

*** Other
Much of the difficulty came from the fact that the implementation for sets in
_Stainless_ is limited. For example, while it is possible to check element
membership, there is no way to actually traverse the elements of the underlying
structure. Also, it is not possible to check the cardinality of the set, as that
functionality is broken (_Stainless_ does not compile any program with calls to
the _size_ method).

With this it became obvious that a solution for this problem would need a new
set implementation. However, with that, properties about sets that we usually
take for granted, such as, e.g., reflexivity and transitivity of equality, or
properties about the relative size of a set and one of its subsets, all need to
be proven. Properties that otherwise _Stainless_ would be able to easily verify,
had we used the set implementation in the _Stainless_ library.

*TODO*: Difficulties with understanding _Stainless_ and its shortcomings.
 Documentation... 

*TODO*: Main difficulty was also figuring out a good representation for automata
 and sets that made the proofs easier

*TODO*: _Stainless_ version used: master branch, commit ddff4c9

** Background Theory
We start by stating our definitions of DFA and NFA, as well as the conversion
algorithm.

- Definition :: A deterministic finite automaton (DFA) is a quintuple
                  (Q,Σ,δ,q0,F), where: 
  1. Q is a finite set (the states);
  2. Σ is a finite set (the alphabet);
  3. δ is a function defined over Q x Σ with values in Q (the transition
     function);
  4. q0 is an element of Q (the initial state);
  5. and F is a subset of Q (the final states).

- Definition :: We say that the DFA $A = (Q,Σ,δ,q0,F)$ accepts the word $w = w_1
                \ldots w_n$, $w_i \in \Sigma$, $ 1 \leq i \leq n$, if there is a
                sequence of states $r_0, \ldots, r_n$, $r_i \in Q$, $0 \leq i
                \leq n$, such that:
  1. $r_0 = q_0$;
  2. δ(r_i, w_{i+1}) = r_{i+1}, $0 \leq i \leq n-1$;
  3. and $r_n \in F$.

- Definition :: The language recognized by the automaton $A = (Q,Σ,δ,q0,F)$ is
                the set $L(A) = \{w \in \Sigma^* : A accepts w\}$.

- Definition :: We say that two automatons are equivalent if they recognize the
                same language.
  
- Definition :: A nondeterministic finite automaton (NFA) is a quintuple
                (Q,Σ,δ,q0,F), where:
  1. Q is a finite set (the states);
  2. Σ is a finite set (the alphabet);
  3. δ is a function defined over Q x (Σ \cup \{ε\}) with values in 2^Q (the
     transition function);
  4. q0 is an element of Q (the initial state);
  5. and F is a subset of Q (the final states).

- 



